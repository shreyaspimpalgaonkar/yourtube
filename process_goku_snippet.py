#!/usr/bin/env -S uv run
# /// script
# requires-python = ">=3.10"
# dependencies = ["moviepy>=2.0", "google-genai", "pillow", "opencv-python", "rich"]
# ///
"""
Process video snippets: Generate logos with Nano Banana, add to frames, 
interpolate with Veo 3.1.

Usage: 
  uv run process_goku_snippet.py <snippet_number>  # Process single snippet
  uv run process_goku_snippet.py --all             # Process all relevant snippets in parallel

Pipeline:
1. Generate logos using Nano Banana
2. Extract first and last frames only
3. Add logo to frames in parallel
4. Generate single 8-second video with Veo 3.1 (preserving music)
"""

import asyncio
import sys
import time
import io
import cv2
import json
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor
from google import genai
from google.genai import types
from PIL import Image
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskProgressColumn, TimeElapsedColumn
from rich.panel import Panel
from rich.table import Table
from rich import print as rprint

console = Console()

# Character/Logo mapping based on snippet labels
# 8, 11, 17, 19, 24, 29 -> Goku -> Red Bull
# 18, 23 -> Vegeta -> Monster
GOKU_SNIPPETS = {8, 11, 17, 19, 24, 31, 29, 44, 57}
VEGETA_SNIPPETS = {18, 20, 23, 28, 33, 46}

LOGOS_DIR = "logos"
PROC_FRAMES_DIR = "proc_frames"
INTERPOLATED_DIR = "interpolated"


def generate_logo_with_nano_banana(prompt: str, output_path: str) -> Image.Image:
    """Generate a logo using Gemini 3 Pro (Nano Banana) for image generation."""
    client = genai.Client()
    
    response = client.models.generate_content(
        model="gemini-3-pro-image-preview",
        contents=prompt,
    )
    
    for part in response.parts:
        if part.inline_data is not None:
            image_data = part.inline_data.data
            logo_image = Image.open(io.BytesIO(image_data))
            logo_image.save(output_path)
            return logo_image
        elif part.text is not None:
            console.print(f"   [dim]üìù Gemini note: {part.text[:100]}...[/dim]")
    
    raise ValueError("No image was generated by Gemini 3")


def create_logos(progress: Progress, task_id) -> dict:
    """Generate Red Bull and Monster logos using Nano Banana."""
    Path(LOGOS_DIR).mkdir(exist_ok=True)
    
    redbull_prompt = """
    Create a clean, simple Red Bull energy drink logo on a transparent/white background.
    The logo should feature two red bulls charging at each other with a yellow/gold sun 
    circle behind them. Bold red and yellow colors. The text "Red Bull" below.
    High quality, crisp edges, vector-style look.
    """
    
    monster_prompt = """
    Create a clean Monster Energy drink logo on a transparent/white background.
    The iconic green "M" claw mark design. Neon green color on black background.
    High quality, crisp edges, bold design.
    """
    
    redbull_path = Path(LOGOS_DIR) / "redbull_logo.png"
    monster_path = Path(LOGOS_DIR) / "monster_logo.png"
    
    logos = {}
    
    if not redbull_path.exists():
        progress.update(task_id, description="[cyan]Generating Red Bull logo...")
        logos['redbull'] = generate_logo_with_nano_banana(redbull_prompt, str(redbull_path))
    else:
        logos['redbull'] = Image.open(redbull_path)
    progress.advance(task_id)
    
    if not monster_path.exists():
        progress.update(task_id, description="[cyan]Generating Monster logo...")
        logos['monster'] = generate_logo_with_nano_banana(monster_prompt, str(monster_path))
    else:
        logos['monster'] = Image.open(monster_path)
    progress.advance(task_id)
    
    return logos


def extract_first_and_last_frames(video_path: str) -> tuple[Image.Image, Image.Image]:
    """Extract only the first and last frames from video."""
    cap = cv2.VideoCapture(video_path)
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    
    # Extract first frame
    ret, first_frame = cap.read()
    if not ret:
        cap.release()
        raise ValueError("Could not read first frame")
    first_rgb = cv2.cvtColor(first_frame, cv2.COLOR_BGR2RGB)
    first_image = Image.fromarray(first_rgb)
    
    # Extract last frame
    cap.set(cv2.CAP_PROP_POS_FRAMES, total_frames - 1)
    ret, last_frame = cap.read()
    if not ret:
        cap.release()
        raise ValueError("Could not read last frame")
    last_rgb = cv2.cvtColor(last_frame, cv2.COLOR_BGR2RGB)
    last_image = Image.fromarray(last_rgb)
    
    cap.release()
    return first_image, last_image


def add_logo_to_frame_sync(image: Image.Image, prompt: str, max_retries: int = 3) -> Image.Image:
    """Synchronous version - Use Gemini 3 Pro to edit the frame and add the logo with retry logic."""
    client = genai.Client()
    
    img_byte_arr = io.BytesIO()
    image.save(img_byte_arr, format='PNG')
    img_bytes = img_byte_arr.getvalue()
    
    image_part = types.Part.from_bytes(
        data=img_bytes,
        mime_type='image/png',
    )
    
    last_error = None
    for attempt in range(max_retries):
        try:
            response = client.models.generate_content(
                model="gemini-3-pro-image-preview",
                contents=[image_part, prompt],
            )
            
            for part in response.parts:
                if part.inline_data is not None:
                    image_data = part.inline_data.data
                    edited_image = Image.open(io.BytesIO(image_data))
                    if attempt > 0:
                        console.print(f"[dim]   ‚úì Retry {attempt} succeeded[/dim]")
                    return edited_image
                elif part.text is not None:
                    # Sometimes Gemini returns text instead of image
                    if attempt < max_retries - 1:
                        console.print(f"[dim]   ‚ö†Ô∏è  Attempt {attempt + 1}: Got text response, retrying...[/dim]")
                        continue
            
            # No image found in response
            if attempt < max_retries - 1:
                wait_time = 2 ** attempt  # Exponential backoff: 1s, 2s, 4s
                console.print(f"[dim]   ‚ö†Ô∏è  Attempt {attempt + 1} failed: No image generated, retrying in {wait_time}s...[/dim]")
                time.sleep(wait_time)
                continue
            else:
                raise ValueError("No image was generated by Gemini 3 after all retries")
                
        except Exception as e:
            last_error = e
            if attempt < max_retries - 1:
                wait_time = 2 ** attempt  # Exponential backoff: 1s, 2s, 4s
                console.print(f"[dim]   ‚ö†Ô∏è  Attempt {attempt + 1} failed: {str(e)[:50]}..., retrying in {wait_time}s...[/dim]")
                time.sleep(wait_time)
            else:
                raise
    
    # If we get here, all retries failed
    raise ValueError(f"No image was generated by Gemini 3 after {max_retries} attempts. Last error: {last_error}")


async def add_logo_to_frame_async(executor, image: Image.Image, prompt: str) -> Image.Image:
    """Async wrapper for logo addition."""
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(executor, add_logo_to_frame_sync, image, prompt)


def check_existing_processed_frames(snippet_num: int, start_frame: int, end_frame: int) -> tuple[Image.Image | None, Image.Image | None]:
    """Check if processed frames already exist and load them."""
    first_frame_path = Path(PROC_FRAMES_DIR) / f"{snippet_num:04d}" / f"{start_frame:04d}" / "processed.png"
    last_frame_path = Path(PROC_FRAMES_DIR) / f"{snippet_num:04d}" / f"{end_frame:04d}" / "processed.png"
    
    first_exists = first_frame_path.exists()
    last_exists = last_frame_path.exists()
    
    first_image = Image.open(first_frame_path) if first_exists else None
    last_image = Image.open(last_frame_path) if last_exists else None
    
    return first_image, last_image


def check_existing_video(snippet_num: int, start_frame: int, end_frame: int) -> str | None:
    """Check if interpolated video already exists."""
    video_path = Path(INTERPOLATED_DIR) / f"{snippet_num:04d}" / f"video_{start_frame}_{end_frame}.mp4"
    if video_path.exists():
        return str(video_path)
    return None


async def process_frames_parallel(first_frame: Image.Image, last_frame: Image.Image, snippet_num: int, start_frame: int, end_frame: int, logo_prompt: str) -> tuple[Image.Image, Image.Image]:
    """Process first and last frames in parallel. Skip if already processed."""
    
    # Check for existing processed frames first
    existing_first, existing_last = check_existing_processed_frames(snippet_num, start_frame, end_frame)
    
    if existing_first is not None and existing_last is not None:
        console.print(f"[dim]   ‚è≠Ô∏è  Skipping frame processing (already exists)[/dim]")
        return existing_first, existing_last
    
    # Create output directories
    first_frame_dir = Path(PROC_FRAMES_DIR) / f"{snippet_num:04d}" / f"{start_frame:04d}"
    last_frame_dir = Path(PROC_FRAMES_DIR) / f"{snippet_num:04d}" / f"{end_frame:04d}"
    first_frame_dir.mkdir(parents=True, exist_ok=True)
    last_frame_dir.mkdir(parents=True, exist_ok=True)
    
    executor = ThreadPoolExecutor(max_workers=2)
    
    async def process_frame(image: Image.Image, frame_dir: Path, frame_num: int, frame_type: str, existing_image: Image.Image | None):
        # Skip if already processed
        if existing_image is not None:
            console.print(f"[dim]   ‚è≠Ô∏è  Skipping {frame_type} frame (already exists)[/dim]")
            return existing_image
        
        original_path = frame_dir / "original.png"
        image.save(original_path)
        
        try:
            processed_image = await add_logo_to_frame_async(executor, image, logo_prompt)
            processed_path = frame_dir / "processed.png"
            processed_image.save(processed_path)
            return processed_image
        except Exception as e:
            console.print(f"[yellow]‚ö†Ô∏è  Failed to process {frame_type} frame: {e}[/yellow]")
            return image
    
    # Process both frames in parallel
    processed_first, processed_last = await asyncio.gather(
        process_frame(first_frame, first_frame_dir, start_frame, "first", existing_first),
        process_frame(last_frame, last_frame_dir, end_frame, "last", existing_last)
    )
    
    executor.shutdown(wait=True)
    return processed_first, processed_last


def interpolate_with_veo_sync(first_frame: Image.Image, last_frame: Image.Image, prompt: str, output_path: str, progress: Progress, task_id, max_retries: int = 2) -> str:
    """Synchronous Veo interpolation with progress updates and retry logic."""
    client = genai.Client()
    
    first_bytes = io.BytesIO()
    first_frame.save(first_bytes, format='PNG')
    first_image = types.Image(image_bytes=first_bytes.getvalue(), mime_type="image/png")
    
    last_bytes = io.BytesIO()
    last_frame.save(last_bytes, format='PNG')
    last_image = types.Image(image_bytes=last_bytes.getvalue(), mime_type="image/png")
    
    last_error = None
    for attempt in range(max_retries):
        try:
            if attempt > 0:
                progress.update(task_id, description=f"[cyan]Retry {attempt + 1}/{max_retries}: Sending to Veo 3.1...")
                time.sleep(10)  # Wait before retry
            else:
                progress.update(task_id, description="[cyan]Sending to Veo 3.1...")
            
            operation = client.models.generate_videos(
                model="veo-3.1-generate-preview",
                prompt=prompt,
                image=first_image,
                config=types.GenerateVideosConfig(
                    last_frame=last_image,
                    duration_seconds="8",
                    aspect_ratio="16:9",
                ),
            )
            
            poll_count = 0
            while not operation.done:
                poll_count += 1
                progress.update(task_id, description=f"[cyan]Generating... ({poll_count * 5}s)")
                time.sleep(5)
                operation = client.operations.get(operation)
            
            if operation.response is None or not hasattr(operation.response, 'generated_videos') or not operation.response.generated_videos:
                if attempt < max_retries - 1:
                    console.print(f"[yellow]   ‚ö†Ô∏è  Attempt {attempt + 1} failed: No video generated, retrying...[/yellow]")
                    continue
                return None
            
            progress.update(task_id, description="[cyan]Downloading video...")
            
            video = operation.response.generated_videos[0]
            client.files.download(file=video.video)
            
            # Ensure output directory exists
            Path(output_path).parent.mkdir(parents=True, exist_ok=True)
            video.video.save(output_path)
            
            if attempt > 0:
                console.print(f"[dim]   ‚úì Retry {attempt + 1} succeeded[/dim]")
            
            return output_path
            
        except Exception as e:
            last_error = e
            if attempt < max_retries - 1:
                console.print(f"[yellow]   ‚ö†Ô∏è  Attempt {attempt + 1} failed: {str(e)[:50]}..., retrying...[/yellow]")
                time.sleep(10)  # Wait before retry
            else:
                console.print(f"[red]   ‚úó All {max_retries} attempts failed: {e}[/red]")
                raise
    
    # Should not reach here, but just in case
    raise ValueError(f"Veo interpolation failed after {max_retries} attempts. Last error: {last_error}")


async def interpolate_with_veo_async(first_frame: Image.Image, last_frame: Image.Image, prompt: str, output_path: str, progress: Progress, task_id) -> str:
    """Async wrapper for Veo interpolation."""
    loop = asyncio.get_event_loop()
    executor = ThreadPoolExecutor(max_workers=1)
    try:
        result = await loop.run_in_executor(
            executor, 
            interpolate_with_veo_sync, 
            first_frame, last_frame, prompt, output_path, progress, task_id
        )
        return result
    finally:
        executor.shutdown(wait=True)


async def generate_single_video(first_frame: Image.Image, last_frame: Image.Image, snippet_num: int, start_frame: int, end_frame: int, character: str) -> str:
    """Generate a single 8-second video from first to last frame."""
    
    interpolation_prompt = f"""
    Create a smooth, natural video transition between these two images.
    This is a scene featuring {character} from an animated series. 
    Generate natural, fluid motion connecting the start frame to the end frame.
    Maintain the visual style, colors, and character appearance throughout.
    IMPORTANT: Preserve the original music and audio style. Do not change the musical 
    tone, rhythm, or energy level. Keep the audio consistent with the original scene's 
    mood and pacing. The music should flow naturally and maintain its original character.
    """
    
    # Create output directory: interpolated/{snippet_num}/
    output_dir = Path(INTERPOLATED_DIR) / f"{snippet_num:04d}"
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Output: interpolated/{snippet_num}/video_{start_frame}_{end_frame}.mp4
    output_path = output_dir / f"video_{start_frame}_{end_frame}.mp4"
    
    # Use async wrapper for Veo interpolation
    loop = asyncio.get_event_loop()
    executor = ThreadPoolExecutor(max_workers=1)
    
    try:
        # Create a simple progress tracker (since we can't share progress across parallel tasks easily)
        class SimpleProgress:
            def __init__(self):
                self.description = f"[cyan]Generating video {snippet_num}: {start_frame} ‚Üí {end_frame}"
            
            def update(self, task_id, description=None):
                if description:
                    self.description = description
        
        progress = SimpleProgress()
        task_id = 0
        
        result = await loop.run_in_executor(
            executor,
            interpolate_with_veo_sync,
            first_frame, last_frame, interpolation_prompt, str(output_path), progress, task_id
        )
        
        if result:
            console.print(f"[green]‚úì Snippet {snippet_num}: Video generated ({start_frame} ‚Üí {end_frame})[/green]")
            return result
        else:
            console.print(f"[yellow]‚ö†Ô∏è Snippet {snippet_num}: Video generation failed[/yellow]")
            return None
    except Exception as e:
        console.print(f"[red]‚úó Snippet {snippet_num}: Error - {e}[/red]")
        return None
    finally:
        executor.shutdown(wait=True)


def get_character_and_logo(snippet_num: int) -> tuple[str, str, str]:
    """Determine character, logo name, and logo prompt based on snippet number."""
    if snippet_num in GOKU_SNIPPETS:
        character = "Goku"
        logo_name = "Red Bull"
        logo_prompt = """
        CRITICAL: DO NOT CHANGE ANYTHING except add a small Red Bull logo.
        Add a Red Bull logo (two red bulls with yellow sun) onto the character's 
        chest area, replacing or covering their existing symbol.
        The output must be PIXEL-FOR-PIXEL IDENTICAL except for the logo area.
        DO NOT change face, hair, body, pose, colors, background, or any other element.
        Think of this as placing a sticker ON TOP of the existing image.
        """
    elif snippet_num in VEGETA_SNIPPETS:
        character = "Vegeta"
        logo_name = "Monster"
        logo_prompt = """
        CRITICAL: DO NOT CHANGE ANYTHING except add Monster logos in a polka-dot pattern.
        Add multiple small Monster Energy logos (green M claw marks) scattered across 
        the character's outfit/armor in a polka-dot fashion (multiple places).
        The output must be PIXEL-FOR-PIXEL IDENTICAL except for the logo areas.
        DO NOT change face, hair, body, pose, colors, background, or any other element.
        Think of this as placing stickers ON TOP of the existing image.
        """
    else:
        character = "Unknown"
        logo_name = "Red Bull"
        logo_prompt = """
        CRITICAL: DO NOT CHANGE ANYTHING except add a small Red Bull logo.
        Add a Red Bull logo onto the main character's chest area.
        The output must be PIXEL-FOR-PIXEL IDENTICAL except for the logo area.
        """
    
    return character, logo_name, logo_prompt


async def process_single_snippet(snippet_num: int, snippets_info: list[dict]) -> dict:
    """Process a single snippet. Skip if video already exists."""
    # Determine character and logo
    character, logo_name, logo_prompt = get_character_and_logo(snippet_num)
    
    snippet_info = snippets_info[snippet_num - 1]
    snippet_video = f"snippets/{snippet_info['filename']}"
    start_frame = snippet_info["start_frame"]
    end_frame = snippet_info["end_frame"]
    duration = snippet_info["duration"]
    
    # Check if video already exists - skip entire snippet
    existing_video = check_existing_video(snippet_num, start_frame, end_frame)
    if existing_video:
        console.print(f"[dim]‚è≠Ô∏è  Snippet {snippet_num}: Already processed, skipping[/dim]")
        return {
            "snippet_num": snippet_num,
            "success": True,
            "video_path": existing_video,
            "character": character,
            "logo_name": logo_name,
            "skipped": True
        }
    
    if not Path(snippet_video).exists():
        return {"snippet_num": snippet_num, "success": False, "error": f"Snippet not found: {snippet_video}"}
    
    try:
        # Step 1: Extract first and last frames
        first_frame, last_frame = extract_first_and_last_frames(snippet_video)
        
        # Step 2: Process frames with logo in parallel (will skip if already processed)
        processed_first, processed_last = await process_frames_parallel(
            first_frame, last_frame, snippet_num, start_frame, end_frame, logo_prompt
        )
        
        # Step 3: Generate single 8-second video
        video_path = await generate_single_video(
            processed_first, processed_last, snippet_num, start_frame, end_frame, character
        )
        
        return {
            "snippet_num": snippet_num,
            "success": video_path is not None,
            "video_path": video_path,
            "character": character,
            "logo_name": logo_name,
            "skipped": False
        }
    except Exception as e:
        return {"snippet_num": snippet_num, "success": False, "error": str(e)}


async def process_all_snippets_parallel():
    """Process all relevant snippets in parallel."""
    # Load snippet info
    with open("snippets/snippets_info.json") as f:
        snippets_info = json.load(f)
    
    # Get all relevant snippet numbers
    all_relevant_snippets = sorted(GOKU_SNIPPETS | VEGETA_SNIPPETS)
    
    console.print(Panel.fit(
        f"[bold cyan]üé¨ BRAND PIPELINE - PARALLEL PROCESSING[/bold cyan]\n"
        f"[white]Processing {len(all_relevant_snippets)} snippets in parallel[/white]\n"
        f"[dim]Goku (Red Bull): {sorted(GOKU_SNIPPETS)}[/dim]\n"
        f"[dim]Vegeta (Monster): {sorted(VEGETA_SNIPPETS)}[/dim]",
        border_style="cyan"
    ))
    
    # Create directories
    Path(LOGOS_DIR).mkdir(exist_ok=True)
    Path(PROC_FRAMES_DIR).mkdir(exist_ok=True)
    Path(INTERPOLATED_DIR).mkdir(exist_ok=True)
    
    # Step 1: Generate logos (once)
    console.rule("[bold]Step 1/3: Generate Logos[/bold]")
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TaskProgressColumn(),
        console=console,
    ) as progress:
        task = progress.add_task("[cyan]Checking logos...", total=2)
        logos = create_logos(progress, task)
    console.print("[green]‚úì Logos ready[/green]\n")
    
    # Step 2 & 3: Process all snippets in parallel
    console.rule(f"[bold]Step 2-3/3: Process {len(all_relevant_snippets)} Snippets[/bold]")
    
    results = []
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TaskProgressColumn(),
        TimeElapsedColumn(),
        console=console,
    ) as progress:
        task = progress.add_task("[cyan]Processing snippets...", total=len(all_relevant_snippets))
        
        # Process all snippets concurrently
        tasks = [
            process_single_snippet(snippet_num, snippets_info) 
            for snippet_num in all_relevant_snippets
        ]
        
        for coro in asyncio.as_completed(tasks):
            result = await coro
            results.append(result)
            progress.advance(task)
            if result["success"]:
                progress.update(task, description=f"[cyan]‚úì Snippet {result['snippet_num']} ({result['character']})")
            else:
                progress.update(task, description=f"[yellow]‚ö†Ô∏è Snippet {result['snippet_num']} failed")
    
    # Summary
    console.rule("[bold green]‚úÖ PIPELINE COMPLETE[/bold green]")
    
    successful = [r for r in results if r["success"]]
    failed = [r for r in results if not r["success"]]
    skipped = [r for r in successful if r.get("skipped", False)]
    newly_processed = [r for r in successful if not r.get("skipped", False)]
    
    summary_table = Table(title="Processing Summary", show_header=True, header_style="bold")
    summary_table.add_column("Status", style="cyan")
    summary_table.add_column("Count", style="white")
    summary_table.add_row("‚úÖ Total Successful", str(len(successful)))
    summary_table.add_row("   ‚è≠Ô∏è  Skipped (already existed)", str(len(skipped)))
    summary_table.add_row("   üÜï Newly Generated", str(len(newly_processed)))
    summary_table.add_row("‚ùå Failed", str(len(failed)))
    console.print(summary_table)
    console.print()
    
    if skipped:
        console.print(f"[dim]‚è≠Ô∏è  Skipped {len(skipped)} snippets (already processed):[/dim]")
        for r in sorted(skipped, key=lambda x: x["snippet_num"]):
            console.print(f"   [dim]‚Ä¢[/dim] Snippet {r['snippet_num']}: {r['character']} ({r['logo_name']}) ‚Üí {r['video_path']}")
        console.print()
    
    if newly_processed:
        console.print(f"[bold green]üéâ Newly generated {len(newly_processed)} snippets:[/bold green]")
        for r in sorted(newly_processed, key=lambda x: x["snippet_num"]):
            console.print(f"   [green]‚Ä¢[/green] Snippet {r['snippet_num']}: {r['character']} ({r['logo_name']}) ‚Üí {r['video_path']}")
    
    if failed:
        console.print(f"\n[yellow]‚ö†Ô∏è Failed snippets:[/yellow]")
        for r in sorted(failed, key=lambda x: x["snippet_num"]):
            console.print(f"   [red]‚Ä¢[/red] Snippet {r['snippet_num']}: {r.get('error', 'Unknown error')}")


async def main_async(snippet_num: int = None):
    """Main async function - process single snippet or all snippets."""
    if snippet_num is None:
        # Process all relevant snippets in parallel
        await process_all_snippets_parallel()
        return
    
    # Process single snippet
    character, logo_name, logo_prompt = get_character_and_logo(snippet_num)
    
    console.print(Panel.fit(
        f"[bold cyan]üé¨ BRAND PIPELINE[/bold cyan]\n"
        f"[white]Add {logo_name} Logo to {character} (Snippet {snippet_num})[/white]",
        border_style="cyan"
    ))
    
    # Load snippet info
    with open("snippets/snippets_info.json") as f:
        snippets_info = json.load(f)
    
    if snippet_num < 1 or snippet_num > len(snippets_info):
        console.print(f"[red]‚ùå Invalid snippet number: {snippet_num}[/red]")
        console.print(f"[dim]   Valid range: 1-{len(snippets_info)}[/dim]")
        return
    
    # Create directories
    Path(LOGOS_DIR).mkdir(exist_ok=True)
    Path(PROC_FRAMES_DIR).mkdir(exist_ok=True)
    Path(INTERPOLATED_DIR).mkdir(exist_ok=True)
    
    # Generate logos
    console.rule("[bold]Step 1/3: Generate Logos[/bold]")
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TaskProgressColumn(),
        console=console,
    ) as progress:
        task = progress.add_task("[cyan]Checking logos...", total=2)
        logos = create_logos(progress, task)
    console.print("[green]‚úì Logos ready[/green]\n")
    
    # Process snippet
    result = await process_single_snippet(snippet_num, snippets_info)
    
    if result["success"]:
        console.print(f"[bold green]‚úÖ Success! Video saved to: {result['video_path']}[/bold green]")
    else:
        console.print(f"[red]‚ùå Failed: {result.get('error', 'Unknown error')}[/red]")


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Process video snippets: Add logos and generate videos with Veo 3.1"
    )
    parser.add_argument(
        "snippet_number",
        nargs="?",
        type=int,
        help="Snippet number to process (or use --all to process all relevant snippets)"
    )
    parser.add_argument(
        "--all",
        action="store_true",
        help="Process all relevant snippets (Goku and Vegeta) in parallel"
    )
    
    args = parser.parse_args()
    
    if args.all:
        asyncio.run(main_async(None))
    elif args.snippet_number:
        asyncio.run(main_async(args.snippet_number))
    else:
        console.print(Panel.fit(
            "[bold]Usage:[/bold]\n"
            "  uv run process_goku_snippet.py <snippet_number>  [dim]# Process single snippet[/dim]\n"
            "  uv run process_goku_snippet.py --all             [dim]# Process all relevant snippets[/dim]\n\n"
            "[bold]Examples:[/bold]\n"
            "  uv run process_goku_snippet.py 8   [dim]# Goku with Red Bull[/dim]\n"
            "  uv run process_goku_snippet.py 18  [dim]# Vegeta with Monster[/dim]\n"
            "  uv run process_goku_snippet.py --all  [dim]# Process all in parallel[/dim]\n\n"
            "[bold]Labeled snippets:[/bold]\n"
            "  [red]Goku (Red Bull):[/red]   8, 11, 17, 19, 24, 29\n"
            "  [green]Vegeta (Monster):[/green]  18, 23",
            title="üé¨ Brand Pipeline",
            border_style="cyan"
        ))
        sys.exit(1)


if __name__ == "__main__":
    main()
